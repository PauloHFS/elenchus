# Server-Sent Events (SSE) Implementation

This document describes the SSE architecture used in the system for real-time updates, such as evaluation progress and background job notifications.

## Architecture

The SSE implementation is centralized in the `internal/sse` package, centered around a global `Broker`.

### 1. The Broker (`internal/sse/broker.go`)
The `Broker` manages active connections and message distribution.
- **Subscriptions**: Clients subscribe to a "Resource Key" (e.g., `user:1` or `evaluation:uuid`).
- **Concurrency**: Uses `sync.RWMutex` to manage multiple clients across different threads.
- **Buffering**: Each client has a buffered channel (`chan string`) to prevent slow consumers from blocking the entire broker.

### 2. The Handler
The SSE endpoint is exposed via `deps.SSEBroker.Handler()` and is typically registered at `/sse`.

**Key requirements fulfilled by the handler:**
- **Headers**:
    - `Content-Type: text/event-stream`
    - `Cache-Control: no-cache`
    - `Connection: keep-alive`
    - `X-Accel-Buffering: no` (Crucial for Nginx/Proxies)
- **Initial Kick**: Sends a `: ok` comment immediately upon connection to acknowledge the stream to the browser.
- **Flushing**: Manually calls `http.Flusher.Flush()` after every write to ensure data is sent over the network immediately.

## Middleware Compatibility

SSE requires a transparent path for the `http.Flusher` interface. The following adjustments were made:

1.  **Logger Middleware**: The custom `responseWriter` implements the `Flush()` method to proxy calls to the underlying `ResponseWriter`.
2.  **CSRF Middleware**: The `/sse` route is exempted from CSRF wrapping because `nosurf` and similar libraries often buffer the response, which breaks streaming.

## Protocol and Formatting

### Multi-line Data
SSE protocol requires each line of data to be prefixed with `data: `. Since we often send HTML generated by Templ (which contains newlines), the `Broker.SendHTML` method automatically:
1.  Splits the HTML string by newlines.
2.  Prefixes every line with `data: `.
3.  Appends `

` at the end of the message.

### Message Format
```text
event: <event_name>
data: <div>
data:   <p>Update content</p>
data: </div>

```

## Frontend Integration (HTMX)

The system uses the [HTMX SSE Extension](https://htmx.org/extensions/sse/).

### 1. Connection
To establish a connection, use the `hx-ext="sse"` and `sse-connect` attributes on a parent element.
```html
<div hx-ext="sse" sse-connect="/sse?type=user&id=1">
    ...
</div>
```

### 2. Swapping Content
To update an element when an event is received, use `sse-swap`.
```html
<div sse-swap="job_progress">
    <!-- This content will be replaced by the data from 'job_progress' events -->
</div>
```

## Backend Usage

To send a real-time update from any service or worker:

```go
// Inside a service or handler
broker.SendHTML("user", "1", "notification", "<div>New message!</div>")
```

For evaluations, specialized methods are available:
- `SendEvaluationProgress(evalID, phase, current, total, html)`
- `SendEvaluationComplete(evalID, html)`
- `SendEvaluationError(evalID, html)`
