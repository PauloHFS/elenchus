// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: checkpoints.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
)

const clearCheckpointRetry = `-- name: ClearCheckpointRetry :exec
UPDATE evaluation_checkpoints
SET next_retry_at = NULL,
    retry_count = 0,
    updated_at = CURRENT_TIMESTAMP
WHERE evaluation_id = ?
`

func (q *Queries) ClearCheckpointRetry(ctx context.Context, evaluationID string) error {
	_, err := q.db.ExecContext(ctx, clearCheckpointRetry, evaluationID)
	return err
}

const createCheckpoint = `-- name: CreateCheckpoint :exec
INSERT INTO evaluation_checkpoints (
    evaluation_id,
    current_phase,
    messages,
    retry_count
) VALUES (?, ?, ?, 0)
ON CONFLICT(evaluation_id) DO UPDATE SET
    current_phase = excluded.current_phase,
    messages = excluded.messages,
    updated_at = CURRENT_TIMESTAMP
`

type CreateCheckpointParams struct {
	EvaluationID string          `json:"evaluation_id"`
	CurrentPhase string          `json:"current_phase"`
	Messages     json.RawMessage `json:"messages"`
}

func (q *Queries) CreateCheckpoint(ctx context.Context, arg CreateCheckpointParams) error {
	_, err := q.db.ExecContext(ctx, createCheckpoint, arg.EvaluationID, arg.CurrentPhase, arg.Messages)
	return err
}

const deleteCheckpoint = `-- name: DeleteCheckpoint :exec
DELETE FROM evaluation_checkpoints WHERE evaluation_id = ?
`

func (q *Queries) DeleteCheckpoint(ctx context.Context, evaluationID string) error {
	_, err := q.db.ExecContext(ctx, deleteCheckpoint, evaluationID)
	return err
}

const getCheckpoint = `-- name: GetCheckpoint :one
SELECT evaluation_id, current_phase, messages, embedding_inicial, embedding_confronto, divergencia_calculada, diagnostico_final, retry_count, last_retry_at, next_retry_at, created_at, updated_at FROM evaluation_checkpoints
WHERE evaluation_id = ?
`

func (q *Queries) GetCheckpoint(ctx context.Context, evaluationID string) (EvaluationCheckpoint, error) {
	row := q.db.QueryRowContext(ctx, getCheckpoint, evaluationID)
	var i EvaluationCheckpoint
	err := row.Scan(
		&i.EvaluationID,
		&i.CurrentPhase,
		&i.Messages,
		&i.EmbeddingInicial,
		&i.EmbeddingConfronto,
		&i.DivergenciaCalculada,
		&i.DiagnosticoFinal,
		&i.RetryCount,
		&i.LastRetryAt,
		&i.NextRetryAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEvaluationsToRetry = `-- name: GetEvaluationsToRetry :many
SELECT e.id, e.tenant_id, e.user_id, e.prompt_base, e.status, e.idempotency_key, e.error_message, e.retry_count, e.created_at FROM evaluations e
INNER JOIN evaluation_checkpoints c ON e.id = c.evaluation_id
WHERE e.status = 'processing'
  AND c.next_retry_at IS NOT NULL
  AND c.next_retry_at <= CURRENT_TIMESTAMP
`

func (q *Queries) GetEvaluationsToRetry(ctx context.Context) ([]Evaluation, error) {
	rows, err := q.db.QueryContext(ctx, getEvaluationsToRetry)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Evaluation
	for rows.Next() {
		var i Evaluation
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UserID,
			&i.PromptBase,
			&i.Status,
			&i.IdempotencyKey,
			&i.ErrorMessage,
			&i.RetryCount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStuckEvaluations = `-- name: GetStuckEvaluations :many
SELECT e.id, e.tenant_id, e.user_id, e.prompt_base, e.status, e.idempotency_key, e.error_message, e.retry_count, e.created_at FROM evaluations e
INNER JOIN evaluation_checkpoints c ON e.id = c.evaluation_id
WHERE e.status = 'processing'
  AND c.next_retry_at IS NULL
  AND e.updated_at < datetime('now', '-5 minutes')
`

func (q *Queries) GetStuckEvaluations(ctx context.Context) ([]Evaluation, error) {
	rows, err := q.db.QueryContext(ctx, getStuckEvaluations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Evaluation
	for rows.Next() {
		var i Evaluation
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UserID,
			&i.PromptBase,
			&i.Status,
			&i.IdempotencyKey,
			&i.ErrorMessage,
			&i.RetryCount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCheckpointDivergence = `-- name: UpdateCheckpointDivergence :exec
UPDATE evaluation_checkpoints
SET divergencia_calculada = ?,
    diagnostico_final = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE evaluation_id = ?
`

type UpdateCheckpointDivergenceParams struct {
	DivergenciaCalculada sql.NullFloat64 `json:"divergencia_calculada"`
	DiagnosticoFinal     sql.NullString  `json:"diagnostico_final"`
	EvaluationID         string          `json:"evaluation_id"`
}

func (q *Queries) UpdateCheckpointDivergence(ctx context.Context, arg UpdateCheckpointDivergenceParams) error {
	_, err := q.db.ExecContext(ctx, updateCheckpointDivergence, arg.DivergenciaCalculada, arg.DiagnosticoFinal, arg.EvaluationID)
	return err
}

const updateCheckpointEmbeddings = `-- name: UpdateCheckpointEmbeddings :exec
UPDATE evaluation_checkpoints
SET embedding_inicial = ?,
    embedding_confronto = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE evaluation_id = ?
`

type UpdateCheckpointEmbeddingsParams struct {
	EmbeddingInicial   []byte `json:"embedding_inicial"`
	EmbeddingConfronto []byte `json:"embedding_confronto"`
	EvaluationID       string `json:"evaluation_id"`
}

func (q *Queries) UpdateCheckpointEmbeddings(ctx context.Context, arg UpdateCheckpointEmbeddingsParams) error {
	_, err := q.db.ExecContext(ctx, updateCheckpointEmbeddings, arg.EmbeddingInicial, arg.EmbeddingConfronto, arg.EvaluationID)
	return err
}

const updateCheckpointMessages = `-- name: UpdateCheckpointMessages :exec
UPDATE evaluation_checkpoints
SET messages = ?
WHERE evaluation_id = ?
`

type UpdateCheckpointMessagesParams struct {
	Messages     json.RawMessage `json:"messages"`
	EvaluationID string          `json:"evaluation_id"`
}

func (q *Queries) UpdateCheckpointMessages(ctx context.Context, arg UpdateCheckpointMessagesParams) error {
	_, err := q.db.ExecContext(ctx, updateCheckpointMessages, arg.Messages, arg.EvaluationID)
	return err
}

const updateCheckpointPhase = `-- name: UpdateCheckpointPhase :exec
UPDATE evaluation_checkpoints
SET current_phase = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE evaluation_id = ?
`

type UpdateCheckpointPhaseParams struct {
	CurrentPhase string `json:"current_phase"`
	EvaluationID string `json:"evaluation_id"`
}

func (q *Queries) UpdateCheckpointPhase(ctx context.Context, arg UpdateCheckpointPhaseParams) error {
	_, err := q.db.ExecContext(ctx, updateCheckpointPhase, arg.CurrentPhase, arg.EvaluationID)
	return err
}

const updateCheckpointRetry = `-- name: UpdateCheckpointRetry :exec
UPDATE evaluation_checkpoints
SET retry_count = retry_count + 1,
    last_retry_at = CURRENT_TIMESTAMP,
    next_retry_at = datetime('now', '+' || ? || ' seconds'),
    updated_at = CURRENT_TIMESTAMP
WHERE evaluation_id = ?
`

type UpdateCheckpointRetryParams struct {
	Column1      sql.NullString `json:"column_1"`
	EvaluationID string         `json:"evaluation_id"`
}

func (q *Queries) UpdateCheckpointRetry(ctx context.Context, arg UpdateCheckpointRetryParams) error {
	_, err := q.db.ExecContext(ctx, updateCheckpointRetry, arg.Column1, arg.EvaluationID)
	return err
}
